/*
 * generated by Xtext 2.10.0
 */
package fr.mleduc.serializer;

import com.google.inject.Inject;
import fr.mleduc.coldLang.And;
import fr.mleduc.coldLang.Application;
import fr.mleduc.coldLang.Artifact;
import fr.mleduc.coldLang.ArtifactRef;
import fr.mleduc.coldLang.ColdLangPackage;
import fr.mleduc.coldLang.Concern;
import fr.mleduc.coldLang.Equiv;
import fr.mleduc.coldLang.Facet;
import fr.mleduc.coldLang.FacetComposition;
import fr.mleduc.coldLang.Feature;
import fr.mleduc.coldLang.Imply;
import fr.mleduc.coldLang.Language;
import fr.mleduc.coldLang.LanguageOperator;
import fr.mleduc.coldLang.Model;
import fr.mleduc.coldLang.Not;
import fr.mleduc.coldLang.OneOf;
import fr.mleduc.coldLang.Or;
import fr.mleduc.coldLang.Perspective;
import fr.mleduc.coldLang.PerspectiveLanguage;
import fr.mleduc.coldLang.SomeOf;
import fr.mleduc.coldLang.Variable;
import fr.mleduc.services.ColdLangGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ColdLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ColdLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ColdLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ColdLangPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case ColdLangPackage.APPLICATION:
				sequence_Application(context, (Application) semanticObject); 
				return; 
			case ColdLangPackage.ARTIFACT:
				sequence_Artifact(context, (Artifact) semanticObject); 
				return; 
			case ColdLangPackage.ARTIFACT_REF:
				sequence_Application(context, (ArtifactRef) semanticObject); 
				return; 
			case ColdLangPackage.CONCERN:
				sequence_Concern(context, (Concern) semanticObject); 
				return; 
			case ColdLangPackage.EQUIV:
				sequence_Equiv(context, (Equiv) semanticObject); 
				return; 
			case ColdLangPackage.FACET:
				sequence_Facet(context, (Facet) semanticObject); 
				return; 
			case ColdLangPackage.FACET_COMPOSITION:
				sequence_FacetComposition(context, (FacetComposition) semanticObject); 
				return; 
			case ColdLangPackage.FEATURE:
				sequence_Feature(context, (Feature) semanticObject); 
				return; 
			case ColdLangPackage.IMPLY:
				sequence_Imply(context, (Imply) semanticObject); 
				return; 
			case ColdLangPackage.LANGUAGE:
				sequence_Language(context, (Language) semanticObject); 
				return; 
			case ColdLangPackage.LANGUAGE_OPERATOR:
				sequence_LanguageOperator(context, (LanguageOperator) semanticObject); 
				return; 
			case ColdLangPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ColdLangPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case ColdLangPackage.ONE_OF:
				sequence_OneOf(context, (OneOf) semanticObject); 
				return; 
			case ColdLangPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case ColdLangPackage.PERSPECTIVE:
				sequence_Perspective(context, (Perspective) semanticObject); 
				return; 
			case ColdLangPackage.PERSPECTIVE_LANGUAGE:
				sequence_PerspectiveLanguage(context, (PerspectiveLanguage) semanticObject); 
				return; 
			case ColdLangPackage.SOME_OF:
				sequence_SomeOf(context, (SomeOf) semanticObject); 
				return; 
			case ColdLangPackage.VARIABLE:
				sequence_Primary(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Condition returns And
	 *     Equiv returns And
	 *     Equiv.Equiv_1_0 returns And
	 *     Imply returns And
	 *     Imply.Imply_1_0 returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Primary)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Application returns Application
	 *
	 * Constraint:
	 *     (languageOperator=[LanguageOperator|ID] applications+=Application applications+=Application*)
	 */
	protected void sequence_Application(ISerializationContext context, Application semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Application returns ArtifactRef
	 *
	 * Constraint:
	 *     artifact=[Artifact|ID]
	 */
	protected void sequence_Application(ISerializationContext context, ArtifactRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.ARTIFACT_REF__ARTIFACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.ARTIFACT_REF__ARTIFACT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getApplicationAccess().getArtifactArtifactIDTerminalRuleCall_0_1_0_1(), semanticObject.getArtifact());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Artifact returns Artifact
	 *
	 * Constraint:
	 *     (name=ID language=[Language|ID])
	 */
	protected void sequence_Artifact(ISerializationContext context, Artifact semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.ARTIFACT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.ARTIFACT__NAME));
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.ARTIFACT__LANGUAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.ARTIFACT__LANGUAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArtifactAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getArtifactAccess().getLanguageLanguageIDTerminalRuleCall_3_0_1(), semanticObject.getLanguage());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Concern returns Concern
	 *
	 * Constraint:
	 *     (name=ID imported+=[Perspective|ID]? (facets+=Facet | artifact+=Artifact)* fm=FeatureModel)
	 */
	protected void sequence_Concern(ISerializationContext context, Concern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Equiv
	 *     Equiv returns Equiv
	 *     Equiv.Equiv_1_0 returns Equiv
	 *     Imply returns Equiv
	 *     Imply.Imply_1_0 returns Equiv
	 *     Or returns Equiv
	 *     Or.Or_1_0 returns Equiv
	 *     And returns Equiv
	 *     And.And_1_0 returns Equiv
	 *     Primary returns Equiv
	 *
	 * Constraint:
	 *     (left=Equiv_Equiv_1_0 right=Imply)
	 */
	protected void sequence_Equiv(ISerializationContext context, Equiv semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.EQUIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.EQUIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.EQUIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.EQUIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquivAccess().getEquivLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEquivAccess().getRightImplyParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FacetComposition returns FacetComposition
	 *
	 * Constraint:
	 *     (perspectiveLanguage=[PerspectiveLanguage|ID] application=Application)
	 */
	protected void sequence_FacetComposition(ISerializationContext context, FacetComposition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.FACET_COMPOSITION__PERSPECTIVE_LANGUAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.FACET_COMPOSITION__PERSPECTIVE_LANGUAGE));
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.FACET_COMPOSITION__APPLICATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.FACET_COMPOSITION__APPLICATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFacetCompositionAccess().getPerspectiveLanguagePerspectiveLanguageIDTerminalRuleCall_0_0_1(), semanticObject.getPerspectiveLanguage());
		feeder.accept(grammarAccess.getFacetCompositionAccess().getApplicationApplicationParserRuleCall_2_0(), semanticObject.getApplication());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Facet returns Facet
	 *
	 * Constraint:
	 *     (name=ID perspective=[Perspective|ID] activation=Condition compositions+=FacetComposition*)
	 */
	protected void sequence_Facet(ISerializationContext context, Facet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureModel returns Feature
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     (optional?='?'? name=ID condition=Condition?)
	 */
	protected void sequence_Feature(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Imply
	 *     Equiv returns Imply
	 *     Equiv.Equiv_1_0 returns Imply
	 *     Imply returns Imply
	 *     Imply.Imply_1_0 returns Imply
	 *     Or returns Imply
	 *     Or.Or_1_0 returns Imply
	 *     And returns Imply
	 *     And.And_1_0 returns Imply
	 *     Primary returns Imply
	 *
	 * Constraint:
	 *     (left=Imply_Imply_1_0 right=Or)
	 */
	protected void sequence_Imply(ISerializationContext context, Imply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.IMPLY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.IMPLY__LEFT));
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.IMPLY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.IMPLY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImplyAccess().getImplyLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getImplyAccess().getRightOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LanguageOperator returns LanguageOperator
	 *
	 * Constraint:
	 *     (name=ID type+=[Language|ID] types+=[Language|ID]* description=STRING)
	 */
	protected void sequence_LanguageOperator(ISerializationContext context, LanguageOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Language returns Language
	 *
	 * Constraint:
	 *     (name=ID operators+=LanguageOperator*)
	 */
	protected void sequence_Language(ISerializationContext context, Language semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (concerns+=Concern | languages+=Language | perspectives+=Perspective)+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureModel returns OneOf
	 *     OneOf returns OneOf
	 *
	 * Constraint:
	 *     (optional?='?'? name=ID children+=FeatureModel* condition=Condition?)
	 */
	protected void sequence_OneOf(ISerializationContext context, OneOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Or
	 *     Equiv returns Or
	 *     Equiv.Equiv_1_0 returns Or
	 *     Imply returns Or
	 *     Imply.Imply_1_0 returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PerspectiveLanguage returns PerspectiveLanguage
	 *
	 * Constraint:
	 *     (name=ID language=[Language|ID] (operator=[LanguageOperator|ID] perspective=[PerspectiveLanguage|IDS])?)
	 */
	protected void sequence_PerspectiveLanguage(ISerializationContext context, PerspectiveLanguage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Perspective returns Perspective
	 *
	 * Constraint:
	 *     (name=ID languages+=PerspectiveLanguage*)
	 */
	protected void sequence_Perspective(ISerializationContext context, Perspective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Not
	 *     Equiv returns Not
	 *     Equiv.Equiv_1_0 returns Not
	 *     Imply returns Not
	 *     Imply.Imply_1_0 returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     next=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.NOT__NEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.NOT__NEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getNextPrimaryParserRuleCall_1_2_0(), semanticObject.getNext());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Variable
	 *     Equiv returns Variable
	 *     Equiv.Equiv_1_0 returns Variable
	 *     Imply returns Variable
	 *     Imply.Imply_1_0 returns Variable
	 *     Or returns Variable
	 *     Or.Or_1_0 returns Variable
	 *     And returns Variable
	 *     And.And_1_0 returns Variable
	 *     Primary returns Variable
	 *
	 * Constraint:
	 *     ref=[FeatureModel|ID]
	 */
	protected void sequence_Primary(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ColdLangPackage.Literals.VARIABLE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ColdLangPackage.Literals.VARIABLE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getRefFeatureModelIDTerminalRuleCall_2_1_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FeatureModel returns SomeOf
	 *     SomeOf returns SomeOf
	 *
	 * Constraint:
	 *     (optional?='?'? name=ID children+=FeatureModel* condition=Condition?)
	 */
	protected void sequence_SomeOf(ISerializationContext context, SomeOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
