/**
 * generated by Xtext 2.10.0
 */
package fr.mleduc.validation;

import com.google.common.base.Objects;
import fr.mleduc.mMLang.MMLangPackage;
import fr.mleduc.mMLang.Metamodel;
import fr.mleduc.validation.AbstractMMLangValidator;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MMLangValidator extends AbstractMMLangValidator {
  private String CIRCULAR_CLASS_HIERARCHY = "CIRCULAR_CLASS_HIERARCHY";
  
  private String UNSOUND_CONCRETE_METAMODEL = "UNSOUND_CONCRETE_METAMODEL";
  
  private String CLASS_NAME_CONFLICT = "CLASS_NAME_CONFLICT";
  
  public void parents(final fr.mleduc.mMLang.Class c, final List<fr.mleduc.mMLang.Class> l) {
    EList<fr.mleduc.mMLang.Class> _parents = c.getParents();
    final Consumer<fr.mleduc.mMLang.Class> _function = (fr.mleduc.mMLang.Class it) -> {
      boolean _contains = l.contains(it);
      boolean _not = (!_contains);
      if (_not) {
        l.add(it);
        this.parents(it, l);
      }
    };
    _parents.forEach(_function);
  }
  
  public List<fr.mleduc.mMLang.Class> parent(final fr.mleduc.mMLang.Class c) {
    ArrayList<fr.mleduc.mMLang.Class> _xblockexpression = null;
    {
      final ArrayList<fr.mleduc.mMLang.Class> l = CollectionLiterals.<fr.mleduc.mMLang.Class>newArrayList();
      this.parents(c, l);
      _xblockexpression = l;
    }
    return _xblockexpression;
  }
  
  @Check
  public void nonCircularHierarchy(final fr.mleduc.mMLang.Class c) {
    EList<fr.mleduc.mMLang.Class> _parents = c.getParents();
    boolean _contains = _parents.contains(c);
    if (_contains) {
      this.error("Circular class hierarchy", MMLangPackage.Literals.CLASS__PARENTS, this.CIRCULAR_CLASS_HIERARCHY);
    }
  }
  
  @Check
  public void checkConcreteMMIsComplete(final Metamodel m) {
    boolean _isConcrete = m.isConcrete();
    if (_isConcrete) {
      EList<fr.mleduc.mMLang.Class> _classes = m.getClasses();
      final Function1<fr.mleduc.mMLang.Class, Boolean> _function = (fr.mleduc.mMLang.Class it) -> {
        return Boolean.valueOf(it.isAbstract());
      };
      Iterable<fr.mleduc.mMLang.Class> _filter = IterableExtensions.<fr.mleduc.mMLang.Class>filter(_classes, _function);
      final Function1<fr.mleduc.mMLang.Class, Boolean> _function_1 = (fr.mleduc.mMLang.Class c1) -> {
        EList<fr.mleduc.mMLang.Class> _classes_1 = m.getClasses();
        final Function1<fr.mleduc.mMLang.Class, Boolean> _function_2 = (fr.mleduc.mMLang.Class it) -> {
          boolean _isAbstract = it.isAbstract();
          return Boolean.valueOf((!_isAbstract));
        };
        Iterable<fr.mleduc.mMLang.Class> _filter_1 = IterableExtensions.<fr.mleduc.mMLang.Class>filter(_classes_1, _function_2);
        final Function1<fr.mleduc.mMLang.Class, Boolean> _function_3 = (fr.mleduc.mMLang.Class c2) -> {
          EList<fr.mleduc.mMLang.Class> _parents = c2.getParents();
          return Boolean.valueOf(_parents.contains(c1));
        };
        boolean _exists = IterableExtensions.<fr.mleduc.mMLang.Class>exists(_filter_1, _function_3);
        return Boolean.valueOf((!_exists));
      };
      Iterable<fr.mleduc.mMLang.Class> _filter_1 = IterableExtensions.<fr.mleduc.mMLang.Class>filter(_filter, _function_1);
      final Function1<fr.mleduc.mMLang.Class, String> _function_2 = (fr.mleduc.mMLang.Class it) -> {
        return it.getName();
      };
      final List<fr.mleduc.mMLang.Class> abstractClassesWithNoChildren = IterableExtensions.<fr.mleduc.mMLang.Class, String>sortBy(_filter_1, _function_2);
      boolean _isEmpty = abstractClassesWithNoChildren.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Classes ");
        {
          boolean _hasElements = false;
          for(final fr.mleduc.mMLang.Class c : abstractClassesWithNoChildren) {
            if (!_hasElements) {
              _hasElements = true;
            } else {
              _builder.appendImmediate(", ", "");
            }
            String _name = c.getName();
            _builder.append(_name, "");
          }
        }
        _builder.append(" don\'t have concrete child.");
        this.error(_builder.toString(), 
          MMLangPackage.Literals.METAMODEL__NAME, this.UNSOUND_CONCRETE_METAMODEL);
      }
    }
  }
  
  @Check
  public void checkClassesNames(final fr.mleduc.mMLang.Class a) {
    EObject _rootContainer = EcoreUtil2.getRootContainer(a);
    final Metamodel mm = ((Metamodel) _rootContainer);
    EList<fr.mleduc.mMLang.Class> _classes = mm.getClasses();
    final Function1<fr.mleduc.mMLang.Class, Boolean> _function = (fr.mleduc.mMLang.Class it) -> {
      return Boolean.valueOf(((it != a) && Objects.equal(it.getName(), a.getName())));
    };
    Iterable<fr.mleduc.mMLang.Class> _filter = IterableExtensions.<fr.mleduc.mMLang.Class>filter(_classes, _function);
    boolean _isEmpty = IterableExtensions.isEmpty(_filter);
    boolean _not = (!_isEmpty);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Another class exists with the same name");
      this.error(_builder.toString(), a, MMLangPackage.Literals.REFERENCE__NAME, this.CLASS_NAME_CONFLICT);
    }
  }
}
