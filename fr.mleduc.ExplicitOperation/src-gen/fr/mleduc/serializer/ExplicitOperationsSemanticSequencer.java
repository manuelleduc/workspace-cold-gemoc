/*
 * generated by Xtext 2.10.0
 */
package fr.mleduc.serializer;

import com.google.inject.Inject;
import fr.mleduc.explicitOperations.And;
import fr.mleduc.explicitOperations.Artifact;
import fr.mleduc.explicitOperations.ArtifactParameter;
import fr.mleduc.explicitOperations.AtomicFeature;
import fr.mleduc.explicitOperations.CardVal0;
import fr.mleduc.explicitOperations.CardVal1;
import fr.mleduc.explicitOperations.CardValN;
import fr.mleduc.explicitOperations.Cardinality;
import fr.mleduc.explicitOperations.Composition;
import fr.mleduc.explicitOperations.CompositionParameter;
import fr.mleduc.explicitOperations.Equiv;
import fr.mleduc.explicitOperations.ExplicitOperationsPackage;
import fr.mleduc.explicitOperations.FeatureModel;
import fr.mleduc.explicitOperations.Imply;
import fr.mleduc.explicitOperations.Language;
import fr.mleduc.explicitOperations.LanguageDependency;
import fr.mleduc.explicitOperations.Model;
import fr.mleduc.explicitOperations.Not;
import fr.mleduc.explicitOperations.OneOf;
import fr.mleduc.explicitOperations.Operation;
import fr.mleduc.explicitOperations.OperationParameter;
import fr.mleduc.explicitOperations.Or;
import fr.mleduc.explicitOperations.SomeOf;
import fr.mleduc.explicitOperations.Variable;
import fr.mleduc.services.ExplicitOperationsGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ExplicitOperationsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ExplicitOperationsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ExplicitOperationsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExplicitOperationsPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case ExplicitOperationsPackage.ARTIFACT:
				sequence_Artifact(context, (Artifact) semanticObject); 
				return; 
			case ExplicitOperationsPackage.ARTIFACT_PARAMETER:
				sequence_ArtifactParameter(context, (ArtifactParameter) semanticObject); 
				return; 
			case ExplicitOperationsPackage.ATOMIC_FEATURE:
				sequence_AtomicFeature(context, (AtomicFeature) semanticObject); 
				return; 
			case ExplicitOperationsPackage.CARD_VAL0:
				sequence_CardVal(context, (CardVal0) semanticObject); 
				return; 
			case ExplicitOperationsPackage.CARD_VAL1:
				sequence_CardVal(context, (CardVal1) semanticObject); 
				return; 
			case ExplicitOperationsPackage.CARD_VAL_N:
				sequence_CardVal(context, (CardValN) semanticObject); 
				return; 
			case ExplicitOperationsPackage.CARDINALITY:
				sequence_Cardinality(context, (Cardinality) semanticObject); 
				return; 
			case ExplicitOperationsPackage.COMPOSITION:
				sequence_Composition(context, (Composition) semanticObject); 
				return; 
			case ExplicitOperationsPackage.COMPOSITION_PARAMETER:
				sequence_CompositionParameter(context, (CompositionParameter) semanticObject); 
				return; 
			case ExplicitOperationsPackage.EQUIV:
				sequence_Equiv(context, (Equiv) semanticObject); 
				return; 
			case ExplicitOperationsPackage.FEATURE_MODEL:
				sequence_FeatureModel(context, (FeatureModel) semanticObject); 
				return; 
			case ExplicitOperationsPackage.IMPLY:
				sequence_Imply(context, (Imply) semanticObject); 
				return; 
			case ExplicitOperationsPackage.LANGUAGE:
				sequence_Language(context, (Language) semanticObject); 
				return; 
			case ExplicitOperationsPackage.LANGUAGE_DEPENDENCY:
				sequence_LanguageDependency(context, (LanguageDependency) semanticObject); 
				return; 
			case ExplicitOperationsPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ExplicitOperationsPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case ExplicitOperationsPackage.ONE_OF:
				sequence_OneOf(context, (OneOf) semanticObject); 
				return; 
			case ExplicitOperationsPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case ExplicitOperationsPackage.OPERATION_PARAMETER:
				sequence_OperationParameter(context, (OperationParameter) semanticObject); 
				return; 
			case ExplicitOperationsPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case ExplicitOperationsPackage.SOME_OF:
				sequence_SomeOf(context, (SomeOf) semanticObject); 
				return; 
			case ExplicitOperationsPackage.VARIABLE:
				sequence_Primary(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Proposition returns And
	 *     Equiv returns And
	 *     Equiv.Equiv_1_0 returns And
	 *     Imply returns And
	 *     Imply.Imply_1_0 returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Primary)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArtifactParameter returns ArtifactParameter
	 *
	 * Constraint:
	 *     (name=[LanguageDependency|ID] artifact=[Referentiable|ID])
	 */
	protected void sequence_ArtifactParameter(ISerializationContext context, ArtifactParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.ARTIFACT_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.ARTIFACT_PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.ARTIFACT_PARAMETER__ARTIFACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.ARTIFACT_PARAMETER__ARTIFACT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArtifactParameterAccess().getNameLanguageDependencyIDTerminalRuleCall_0_0_1(), semanticObject.getName());
		feeder.accept(grammarAccess.getArtifactParameterAccess().getArtifactReferentiableIDTerminalRuleCall_2_0_1(), semanticObject.getArtifact());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Artifact returns Artifact
	 *     Referentiable returns Artifact
	 *
	 * Constraint:
	 *     (name=ID type=[Language|ID] parameters+=ArtifactParameter*)
	 */
	protected void sequence_Artifact(ISerializationContext context, Artifact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns AtomicFeature
	 *     AtomicFeature returns AtomicFeature
	 *
	 * Constraint:
	 *     (optional?='?'? name=ID constraints=Proposition?)
	 */
	protected void sequence_AtomicFeature(ISerializationContext context, AtomicFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CardVal returns CardVal0
	 *
	 * Constraint:
	 *     {CardVal0}
	 */
	protected void sequence_CardVal(ISerializationContext context, CardVal0 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CardVal returns CardVal1
	 *
	 * Constraint:
	 *     {CardVal1}
	 */
	protected void sequence_CardVal(ISerializationContext context, CardVal1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CardVal returns CardValN
	 *
	 * Constraint:
	 *     {CardValN}
	 */
	protected void sequence_CardVal(ISerializationContext context, CardValN semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cardinality returns Cardinality
	 *
	 * Constraint:
	 *     (start=CardVal stop=CardVal)
	 */
	protected void sequence_Cardinality(ISerializationContext context, Cardinality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.CARDINALITY__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.CARDINALITY__START));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.CARDINALITY__STOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.CARDINALITY__STOP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCardinalityAccess().getStartCardValParserRuleCall_1_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getCardinalityAccess().getStopCardValParserRuleCall_3_0(), semanticObject.getStop());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompositionParameter returns CompositionParameter
	 *
	 * Constraint:
	 *     (name=[OperationParameter|ID] artifact=[Referentiable|ID])
	 */
	protected void sequence_CompositionParameter(ISerializationContext context, CompositionParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.COMPOSITION_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.COMPOSITION_PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.COMPOSITION_PARAMETER__ARTIFACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.COMPOSITION_PARAMETER__ARTIFACT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompositionParameterAccess().getNameOperationParameterIDTerminalRuleCall_0_0_1(), semanticObject.getName());
		feeder.accept(grammarAccess.getCompositionParameterAccess().getArtifactReferentiableIDTerminalRuleCall_2_0_1(), semanticObject.getArtifact());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Referentiable returns Composition
	 *     Composition returns Composition
	 *
	 * Constraint:
	 *     (name=ID operation=[Operation|ID] activation=Proposition parameters+=CompositionParameter*)
	 */
	protected void sequence_Composition(ISerializationContext context, Composition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Proposition returns Equiv
	 *     Equiv returns Equiv
	 *     Equiv.Equiv_1_0 returns Equiv
	 *     Imply returns Equiv
	 *     Imply.Imply_1_0 returns Equiv
	 *     Or returns Equiv
	 *     Or.Or_1_0 returns Equiv
	 *     And returns Equiv
	 *     And.And_1_0 returns Equiv
	 *     Primary returns Equiv
	 *
	 * Constraint:
	 *     (left=Equiv_Equiv_1_0 right=Imply)
	 */
	protected void sequence_Equiv(ISerializationContext context, Equiv semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.EQUIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.EQUIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.EQUIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.EQUIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquivAccess().getEquivLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEquivAccess().getRightImplyParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FeatureModel returns FeatureModel
	 *
	 * Constraint:
	 *     (name=ID feature=Feature)
	 */
	protected void sequence_FeatureModel(ISerializationContext context, FeatureModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.FEATURE_MODEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.FEATURE_MODEL__NAME));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.FEATURE_MODEL__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.FEATURE_MODEL__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureModelAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFeatureModelAccess().getFeatureFeatureParserRuleCall_2_0(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Proposition returns Imply
	 *     Equiv returns Imply
	 *     Equiv.Equiv_1_0 returns Imply
	 *     Imply returns Imply
	 *     Imply.Imply_1_0 returns Imply
	 *     Or returns Imply
	 *     Or.Or_1_0 returns Imply
	 *     And returns Imply
	 *     And.And_1_0 returns Imply
	 *     Primary returns Imply
	 *
	 * Constraint:
	 *     (left=Imply_Imply_1_0 right=Or)
	 */
	protected void sequence_Imply(ISerializationContext context, Imply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.IMPLY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.IMPLY__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.IMPLY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.IMPLY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImplyAccess().getImplyLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getImplyAccess().getRightOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LanguageDependency returns LanguageDependency
	 *
	 * Constraint:
	 *     (name=ID type=[Language|ID])
	 */
	protected void sequence_LanguageDependency(ISerializationContext context, LanguageDependency semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.LANGUAGE_DEPENDENCY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.LANGUAGE_DEPENDENCY__NAME));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.LANGUAGE_DEPENDENCY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.LANGUAGE_DEPENDENCY__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLanguageDependencyAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLanguageDependencyAccess().getTypeLanguageIDTerminalRuleCall_2_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Language returns Language
	 *
	 * Constraint:
	 *     (name=ID dependencies+=LanguageDependency*)
	 */
	protected void sequence_Language(ISerializationContext context, Language semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID (languages+=Language | operations+=Operation | artifacts+=Artifact | compositions+=Composition | featureModels+=FeatureModel)*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns OneOf
	 *     OneOf returns OneOf
	 *
	 * Constraint:
	 *     (optional?='?'? name=ID children+=Feature* constraints=Proposition?)
	 */
	protected void sequence_OneOf(ISerializationContext context, OneOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperationParameter returns OperationParameter
	 *
	 * Constraint:
	 *     (name=ID type=[Language|ID] cardinality=Cardinality)
	 */
	protected void sequence_OperationParameter(ISerializationContext context, OperationParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__CARDINALITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__CARDINALITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOperationParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOperationParameterAccess().getTypeLanguageIDTerminalRuleCall_2_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getOperationParameterAccess().getCardinalityCardinalityParserRuleCall_3_0(), semanticObject.getCardinality());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (name=ID inputs+=OperationParameter* output=OperationParameter)
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Proposition returns Or
	 *     Equiv returns Or
	 *     Equiv.Equiv_1_0 returns Or
	 *     Imply returns Or
	 *     Imply.Imply_1_0 returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Proposition returns Not
	 *     Equiv returns Not
	 *     Equiv.Equiv_1_0 returns Not
	 *     Imply returns Not
	 *     Imply.Imply_1_0 returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     next=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.NOT__NEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.NOT__NEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getNextPrimaryParserRuleCall_1_2_0(), semanticObject.getNext());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Proposition returns Variable
	 *     Equiv returns Variable
	 *     Equiv.Equiv_1_0 returns Variable
	 *     Imply returns Variable
	 *     Imply.Imply_1_0 returns Variable
	 *     Or returns Variable
	 *     Or.Or_1_0 returns Variable
	 *     And returns Variable
	 *     And.And_1_0 returns Variable
	 *     Primary returns Variable
	 *
	 * Constraint:
	 *     ref=[Feature|ID]
	 */
	protected void sequence_Primary(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.VARIABLE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.VARIABLE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getRefFeatureIDTerminalRuleCall_2_1_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns SomeOf
	 *     SomeOf returns SomeOf
	 *
	 * Constraint:
	 *     (optional?='?'? name=ID children+=Feature* constraints=Proposition?)
	 */
	protected void sequence_SomeOf(ISerializationContext context, SomeOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
