/*
 * generated by Xtext 2.10.0
 */
package fr.mleduc.serializer;

import com.google.inject.Inject;
import fr.mleduc.explicitOperations.Artifact;
import fr.mleduc.explicitOperations.CardVal0;
import fr.mleduc.explicitOperations.CardVal1;
import fr.mleduc.explicitOperations.CardValN;
import fr.mleduc.explicitOperations.Cardinality;
import fr.mleduc.explicitOperations.Composition;
import fr.mleduc.explicitOperations.CompositionParameter;
import fr.mleduc.explicitOperations.ExplicitOperationsPackage;
import fr.mleduc.explicitOperations.Language;
import fr.mleduc.explicitOperations.LanguageDependency;
import fr.mleduc.explicitOperations.Model;
import fr.mleduc.explicitOperations.Operation;
import fr.mleduc.explicitOperations.OperationParameter;
import fr.mleduc.services.ExplicitOperationsGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ExplicitOperationsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ExplicitOperationsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ExplicitOperationsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExplicitOperationsPackage.ARTIFACT:
				sequence_Artifact(context, (Artifact) semanticObject); 
				return; 
			case ExplicitOperationsPackage.CARD_VAL0:
				sequence_CardVal(context, (CardVal0) semanticObject); 
				return; 
			case ExplicitOperationsPackage.CARD_VAL1:
				sequence_CardVal(context, (CardVal1) semanticObject); 
				return; 
			case ExplicitOperationsPackage.CARD_VAL_N:
				sequence_CardVal(context, (CardValN) semanticObject); 
				return; 
			case ExplicitOperationsPackage.CARDINALITY:
				sequence_Cardinality(context, (Cardinality) semanticObject); 
				return; 
			case ExplicitOperationsPackage.COMPOSITION:
				sequence_Composition(context, (Composition) semanticObject); 
				return; 
			case ExplicitOperationsPackage.COMPOSITION_PARAMETER:
				sequence_CompositionParameter(context, (CompositionParameter) semanticObject); 
				return; 
			case ExplicitOperationsPackage.LANGUAGE:
				sequence_Language(context, (Language) semanticObject); 
				return; 
			case ExplicitOperationsPackage.LANGUAGE_DEPENDENCY:
				sequence_LanguageDependency(context, (LanguageDependency) semanticObject); 
				return; 
			case ExplicitOperationsPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ExplicitOperationsPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case ExplicitOperationsPackage.OPERATION_PARAMETER:
				sequence_OperationParameter(context, (OperationParameter) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Artifact returns Artifact
	 *     Referentiable returns Artifact
	 *
	 * Constraint:
	 *     (name=ID type=[Language|ID])
	 */
	protected void sequence_Artifact(ISerializationContext context, Artifact semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.REFERENTIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.REFERENTIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.ARTIFACT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.ARTIFACT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArtifactAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getArtifactAccess().getTypeLanguageIDTerminalRuleCall_3_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CardVal returns CardVal0
	 *
	 * Constraint:
	 *     {CardVal0}
	 */
	protected void sequence_CardVal(ISerializationContext context, CardVal0 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CardVal returns CardVal1
	 *
	 * Constraint:
	 *     {CardVal1}
	 */
	protected void sequence_CardVal(ISerializationContext context, CardVal1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CardVal returns CardValN
	 *
	 * Constraint:
	 *     {CardValN}
	 */
	protected void sequence_CardVal(ISerializationContext context, CardValN semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cardinality returns Cardinality
	 *
	 * Constraint:
	 *     (start=CardVal stop=CardVal)
	 */
	protected void sequence_Cardinality(ISerializationContext context, Cardinality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.CARDINALITY__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.CARDINALITY__START));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.CARDINALITY__STOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.CARDINALITY__STOP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCardinalityAccess().getStartCardValParserRuleCall_1_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getCardinalityAccess().getStopCardValParserRuleCall_3_0(), semanticObject.getStop());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompositionParameter returns CompositionParameter
	 *
	 * Constraint:
	 *     (name=[OperationParameter|ID] artifact=[Referentiable|ID])
	 */
	protected void sequence_CompositionParameter(ISerializationContext context, CompositionParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.COMPOSITION_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.COMPOSITION_PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.COMPOSITION_PARAMETER__ARTIFACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.COMPOSITION_PARAMETER__ARTIFACT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompositionParameterAccess().getNameOperationParameterIDTerminalRuleCall_0_0_1(), semanticObject.getName());
		feeder.accept(grammarAccess.getCompositionParameterAccess().getArtifactReferentiableIDTerminalRuleCall_2_0_1(), semanticObject.getArtifact());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Referentiable returns Composition
	 *     Composition returns Composition
	 *
	 * Constraint:
	 *     (name=ID operation=[Operation|ID] parameters+=CompositionParameter*)
	 */
	protected void sequence_Composition(ISerializationContext context, Composition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LanguageDependency returns LanguageDependency
	 *
	 * Constraint:
	 *     (name=ID type=[Language|ID])
	 */
	protected void sequence_LanguageDependency(ISerializationContext context, LanguageDependency semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.LANGUAGE_DEPENDENCY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.LANGUAGE_DEPENDENCY__NAME));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.LANGUAGE_DEPENDENCY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.LANGUAGE_DEPENDENCY__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLanguageDependencyAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLanguageDependencyAccess().getTypeLanguageIDTerminalRuleCall_2_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Language returns Language
	 *
	 * Constraint:
	 *     (name=ID dependencies+=LanguageDependency*)
	 */
	protected void sequence_Language(ISerializationContext context, Language semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID (languages+=Language | operations+=Operation | artifacts+=Artifact | compositions+=Composition)*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperationParameter returns OperationParameter
	 *
	 * Constraint:
	 *     (name=ID type=[Language|ID] cardinality=Cardinality)
	 */
	protected void sequence_OperationParameter(ISerializationContext context, OperationParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__CARDINALITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExplicitOperationsPackage.Literals.OPERATION_PARAMETER__CARDINALITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOperationParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOperationParameterAccess().getTypeLanguageIDTerminalRuleCall_2_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getOperationParameterAccess().getCardinalityCardinalityParserRuleCall_3_0(), semanticObject.getCardinality());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (name=ID inputs+=OperationParameter* output=OperationParameter)
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
